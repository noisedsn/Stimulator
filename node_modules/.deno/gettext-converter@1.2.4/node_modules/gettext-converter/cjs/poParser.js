"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _encoding = _interopRequireDefault(require("encoding"));
var _shared = require("./shared.js");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var states = {
  none: 0x01,
  comments: 0x02,
  key: 0x03,
  string: 0x04
};
var types = {
  comments: 0x01,
  key: 0x02,
  string: 0x03
};
var symbols = {
  quotes: /["']/,
  comments: /#/,
  whitespace: /\s/,
  key: /[\w\-[\]]/,
  keyNames: /^(?:msgctxt|msgid(?:_plural)?|msgstr(?:\[\d+])?)$/
};
var toString = function toString(buf, charset) {
  return _encoding.default.convert(buf, 'utf-8', charset).toString('utf-8');
};
var parseHeader = function parseHeader() {
  var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return str.split('\n').reduce(function (headers, line) {
    var parts = line.split(':');
    var key = (parts.shift() || '').trim();
    if (key) {
      var value = parts.join(':').trim();
      key = _shared.HEADERS.get(key.toLowerCase()) || key;
      headers[key] = value;
    }
    return headers;
  }, {});
};
var handleCharset = function handleCharset() {
  var buf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var defaultCharset = arguments.length > 1 ? arguments[1] : undefined;
  var str = buf.toString();
  var pos;
  var headers = '';
  var match;
  var charset = defaultCharset;
  if ((pos = str.search(/^\s*msgid/im)) >= 0) {
    pos = pos + str.substr(pos + 5).search(/^\s*(msgid|msgctxt)/im);
    headers = str.substr(0, pos >= 0 ? pos + 5 : str.length);
  }
  if (match = headers.match(/[; ]charset\s*=\s*([\w-]+)(?:[\s;]|\\n)*"\s*$/mi)) {
    charset = (0, _shared.formatCharset)(match[1], defaultCharset);
  }
  if (charset === 'utf-8') {
    return {
      fileContents: str,
      charset: charset
    };
  }
  return {
    fileContents: toString(buf),
    charset: charset
  };
};
var lexer = function lexer(chunk) {
  var lex = [];
  var node = {};
  var state = states.none;
  var lineNumber = 1;
  var escaped = false;
  var chr;
  for (var i = 0, len = chunk.length; i < len; i++) {
    chr = chunk.charAt(i);
    if (chr === '\n') lineNumber += 1;
    switch (state) {
      case states.none:
        if (chr.match(symbols.quotes)) {
          node = {
            type: types.string,
            value: '',
            quote: chr
          };
          lex.push(node);
          state = states.string;
        } else if (chr.match(symbols.comments)) {
          node = {
            type: types.comments,
            value: ''
          };
          lex.push(node);
          state = states.comments;
        } else if (!chr.match(symbols.whitespace)) {
          node = {
            type: types.key,
            value: chr
          };
          lex.push(node);
          state = states.key;
        }
        break;
      case states.comments:
        if (chr === '\n') {
          state = states.none;
        } else if (chr !== '\r') {
          node.value += chr;
        }
        break;
      case states.string:
        if (escaped) {
          switch (chr) {
            case 't':
              node.value += '\t';
              break;
            case 'n':
              node.value += '\n';
              break;
            case 'r':
              node.value += '\r';
              break;
            default:
              node.value += chr;
          }
          escaped = false;
        } else {
          if (chr === node.quote) {
            state = states.none;
          } else if (chr === '\\') {
            escaped = true;
            break;
          } else {
            node.value += chr;
          }
          escaped = false;
        }
        break;
      case states.key:
        if (!chr.match(symbols.key)) {
          if (!node.value.match(symbols.keyNames)) {
            var err = new SyntaxError("Error parsing PO data: Invalid key name \"".concat(node.value, "\" at line ").concat(lineNumber, ". This can be caused by an unescaped quote character in a msgid or msgstr value."));
            err.lineNumber = lineNumber;
            throw err;
          }
          state = states.none;
          i--;
        } else {
          node.value += chr;
        }
        break;
    }
  }
  return lex;
};
var joinStringValues = function joinStringValues(tokens) {
  var response = [];
  var lastNode;
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (lastNode && tokens[i].type === types.string && lastNode.type === types.string) {
      lastNode.value += tokens[i].value;
    } else if (lastNode && tokens[i].type === types.comments && lastNode.type === types.comments) {
      lastNode.value += '\n' + tokens[i].value;
    } else {
      response.push(tokens[i]);
      lastNode = tokens[i];
    }
  }
  return response;
};
var parseComments = function parseComments(tokens) {
  tokens.forEach(function (node) {
    var comment;
    var lines;
    if (node && node.type === types.comments) {
      comment = {
        translator: [],
        extracted: [],
        reference: [],
        flag: [],
        previous: []
      };
      lines = (node.value || '').split(/\n/);
      lines.forEach(function (line) {
        switch (line.charAt(0) || '') {
          case ':':
            comment.reference.push(line.substr(1).trim());
            break;
          case '.':
            comment.extracted.push(line.substr(1).replace(/^\s+/, ''));
            break;
          case ',':
            comment.flag.push(line.substr(1).replace(/^\s+/, ''));
            break;
          case '|':
            comment.previous.push(line.substr(1).replace(/^\s+/, ''));
            break;
          default:
            comment.translator.push(line.replace(/^\s+/, ''));
        }
      });
      node.value = {};
      Object.keys(comment).forEach(function (key) {
        if (comment[key] && comment[key].length) {
          node.value[key] = comment[key].join('\n');
        }
      });
    }
  });
};
var handleKeys = function handleKeys(tokens) {
  var response = [];
  var lastNode;
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === types.key) {
      lastNode = {
        key: tokens[i].value
      };
      if (i && tokens[i - 1].type === types.comments) {
        lastNode.comments = tokens[i - 1].value;
      }
      lastNode.value = '';
      response.push(lastNode);
    } else if (tokens[i].type === types.string && lastNode) {
      lastNode.value += tokens[i].value;
    }
  }
  return response;
};
var handleValues = function handleValues(tokens) {
  var response = [];
  var lastNode;
  var curContext;
  var curComments;
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].key.toLowerCase() === 'msgctxt') {
      curContext = tokens[i].value;
      curComments = tokens[i].comments;
    } else if (tokens[i].key.toLowerCase() === 'msgid') {
      lastNode = {
        msgid: tokens[i].value
      };
      if (curContext) lastNode.msgctxt = curContext;
      if (curComments) lastNode.comments = curComments;
      if (tokens[i].comments && !lastNode.comments) lastNode.comments = tokens[i].comments;
      curContext = false;
      curComments = false;
      response.push(lastNode);
    } else if (tokens[i].key.toLowerCase() === 'msgid_plural') {
      if (lastNode) lastNode.msgid_plural = tokens[i].value;
      if (tokens[i].comments && !lastNode.comments) lastNode.comments = tokens[i].comments;
      curContext = false;
      curComments = false;
    } else if (tokens[i].key.substr(0, 6).toLowerCase() === 'msgstr') {
      if (lastNode) lastNode.msgstr = (lastNode.msgstr || []).concat(tokens[i].value);
      if (tokens[i].comments && !lastNode.comments) lastNode.comments = tokens[i].comments;
      curContext = false;
      curComments = false;
    }
  }
  return response;
};
var normalize = function normalize(tokens, charset) {
  var table = {
    charset: charset,
    headers: undefined,
    translations: {}
  };
  var msgctxt;
  for (var i = 0, len = tokens.length; i < len; i++) {
    msgctxt = tokens[i].msgctxt || '';
    if (!table.translations[msgctxt]) table.translations[msgctxt] = {};
    if (!table.headers && !msgctxt && !tokens[i].msgid) {
      table.headers = parseHeader(tokens[i].msgstr[0]);
    }
    table.translations[msgctxt][tokens[i].msgid] = tokens[i];
  }
  return table;
};
var finalize = function finalize(tokens, charset) {
  var data = joinStringValues(tokens);
  parseComments(data);
  data = handleKeys(data);
  data = handleValues(data);
  return normalize(data, charset);
};
function _default(fileContents) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (typeof options === 'string') {
    options = {
      charset: options
    };
  }
  options.charset = options.charset || 'iso-8859-1';
  if (typeof fileContents === 'string') {
    options.charset = 'utf-8';
  } else {
    var ret = handleCharset(fileContents);
    options.charset = ret.charset;
    fileContents = ret.fileContents;
  }
  var lex = lexer(fileContents);
  return finalize(lex, options.charset);
}
module.exports = exports.default;