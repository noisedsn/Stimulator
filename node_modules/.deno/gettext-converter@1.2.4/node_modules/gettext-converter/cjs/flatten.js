"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _cldrConv = _interopRequireDefault(require("./cldrConv.js"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var FORMS = ['zero', 'one', 'two', 'few', 'many', 'other'];
var regexIndexOf = function regexIndexOf(value, regex, startpos) {
  var indexOf = value.substring(startpos || 0).search(regex);
  return indexOf >= 0 ? indexOf + (startpos || 0) : indexOf;
};
function _default(input) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref$keyseparator = _ref.keyseparator,
    keyseparator = _ref$keyseparator === void 0 ? '##' : _ref$keyseparator,
    _ref$ctxSeparator = _ref.ctxSeparator,
    ctxSeparator = _ref$ctxSeparator === void 0 ? '_' : _ref$ctxSeparator,
    ignorePlurals = _ref.ignorePlurals,
    compatibilityJSON = _ref.compatibilityJSON,
    language = _ref.language;
  var locale = arguments.length > 2 ? arguments[2] : undefined;
  var flat = {};
  function handleOldFormat(appendTo, obj, parentKey) {
    Object.keys(obj || {}).forEach(function (m) {
      var kv;
      var key = parentKey;
      var context = '';
      var value = obj[m];
      if (key.length > 0) {
        key = key + keyseparator + m;
      } else {
        key = m;
      }
      var pluralIndex = key.indexOf('_plural');
      if (pluralIndex < 0) pluralIndex = regexIndexOf(key, /_\d+$/);
      var isPlural = pluralIndex > -1;
      if (ignorePlurals) isPlural = false;
      var number;
      if (isPlural && key.indexOf('_plural') < 0) {
        number = parseInt(key.substring(pluralIndex + 1), 10);
        if (number === 1) isPlural = false;
        key = key.substring(0, pluralIndex);
      } else if (key.indexOf('_plural') > -1) {
        number = 2;
        key = key.substring(0, pluralIndex);
      }
      var ctxKey = key;
      if (isPlural) {
        ctxKey = ctxKey.substring(0, pluralIndex);
        if (ctxKey.indexOf(ctxSeparator) > -1) {
          context = ctxKey.substring(ctxKey.lastIndexOf(ctxSeparator) + ctxSeparator.length, ctxKey.length);
        }
      } else if (key.indexOf(ctxSeparator) > -1) {
        context = ctxKey.substring(ctxKey.lastIndexOf(ctxSeparator) + ctxSeparator.length, ctxKey.length);
      } else {
        context = '';
      }
      if (context === key) context = '';
      if (context !== '') key = key.replace(ctxSeparator + context, '');
      var appendKey = key + context;
      if (isPlural) appendKey = "".concat(appendKey, "_").concat(number);
      if (typeof value === 'string') {
        kv = {
          key: key,
          value: value,
          isPlural: isPlural,
          pluralNumber: isPlural ? number : 0,
          context: context
        };
        appendTo[appendKey] = kv;
      } else if (Array.isArray(value)) {
        kv = {
          key: key,
          value: value.join('\n'),
          isArray: true,
          isPlural: isPlural,
          pluralNumber: isPlural ? number : 0,
          context: context
        };
        appendTo[appendKey] = kv;
      } else {
        recurse(appendTo, value, key);
      }
    });
  }
  function handleNewFormat(appendTo, obj, parentKey) {
    Object.keys(obj).forEach(function (m) {
      var kv;
      var key = parentKey;
      var context = '';
      var value = obj[m];
      if (key.length > 0) {
        key = key + keyseparator + m;
      } else {
        key = m;
      }
      var pluralIndex = key.indexOf('_other');
      if (pluralIndex < 0) pluralIndex = regexIndexOf(key, new RegExp("_(".concat(FORMS.join('|'), ")$")));
      var isPlural = pluralIndex > -1;
      var code = locale || language;
      var cldrRule = _cldrConv.default[code] || _cldrConv.default[code.split(/-|_/)[0]];
      if (!cldrRule && locale && language) {
        cldrRule = _cldrConv.default[language] || _cldrConv.default[language.split(/-|_/)[0]];
      }
      if (!cldrRule) isPlural = false;
      if (ignorePlurals) isPlural = false;
      var form;
      var number = 0;
      if (isPlural && key.indexOf('_other') < 0) {
        form = key.substring(pluralIndex + 1);
        var oldSuffix = cldrRule.fromCldr[FORMS.indexOf(form)];
        if (!oldSuffix) {
          isPlural = false;
        } else {
          number = parseInt(oldSuffix.substring(1), 10);
        }
        if (number === 1) isPlural = false;
        key = key.substring(0, pluralIndex);
      } else if (key.indexOf('_other') > -1) {
        number = 2;
        key = key.substring(0, pluralIndex);
        form = '_other';
      }
      var ctxKey = key;
      if (isPlural) {
        ctxKey = ctxKey.substring(0, pluralIndex);
        if (ctxKey.indexOf(ctxSeparator) > -1) {
          context = ctxKey.substring(ctxKey.lastIndexOf(ctxSeparator) + ctxSeparator.length, ctxKey.length);
        }
      } else if (key.indexOf(ctxSeparator) > -1) {
        context = ctxKey.substring(ctxKey.lastIndexOf(ctxSeparator) + ctxSeparator.length, ctxKey.length);
      } else {
        context = '';
      }
      if (context === key) context = '';
      if (context !== '') key = key.replace(ctxSeparator + context, '');
      var appendKey = key + context;
      if (isPlural) appendKey = "".concat(appendKey, "_").concat(number);
      if (typeof value === 'string') {
        kv = {
          key: key,
          value: value,
          isPlural: isPlural,
          pluralNumber: isPlural ? number : 0,
          context: context
        };
        appendTo[appendKey] = kv;
      } else if (Array.isArray(value)) {
        kv = {
          key: key,
          value: value.join('\n'),
          isArray: true,
          isPlural: isPlural,
          pluralNumber: isPlural ? number : 0,
          context: context
        };
        appendTo[appendKey] = kv;
      } else {
        recurse(appendTo, value, key);
      }
    });
  }
  function recurse(appendTo, obj, parentKey) {
    if (compatibilityJSON === 'v4') {
      handleNewFormat(appendTo, obj, parentKey);
    } else {
      handleOldFormat(appendTo, obj, parentKey);
    }
  }
  recurse(flat, input, '');
  Object.keys(flat).forEach(function (m) {
    var kv = flat[m];
    if (kv.isPlural) {
      if (!flat[kv.key + kv.context]) {
        flat[kv.key + kv.context] = {
          key: kv.key,
          context: kv.context
        };
      }
      var single = flat[kv.key + kv.context];
      if (single) {
        single.plurals = [].concat(_toConsumableArray(single.plurals || []), [kv]);
        delete flat[m];
      }
    }
  });
  return flat;
}
module.exports = exports.default;