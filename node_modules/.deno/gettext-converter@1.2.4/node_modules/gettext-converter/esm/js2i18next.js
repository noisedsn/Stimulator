function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
import { getPlurals } from './options.js';
import cldrConv from './cldrConv.js';
var FORMS = ['zero', 'one', 'two', 'few', 'many', 'other'];
var isFuzzy = function isFuzzy(translation) {
  return !!translation.comments && translation.comments.flag === 'fuzzy';
};
var toArrayIfNeeded = function toArrayIfNeeded(value, _ref) {
  var splitNewLine = _ref.splitNewLine;
  return value.indexOf('\n') > -1 && splitNewLine ? value.split('\n') : value;
};
var emptyOrObject = function emptyOrObject(key, value, options) {
  if (options.skipUntranslated && !value) {
    return {};
  }
  return _defineProperty({}, key, toArrayIfNeeded(value, options));
};
var getI18nextPluralExtension = function getI18nextPluralExtension(ext, i) {
  if (ext && ext.numbers && ext.numbers.length === 2) return i === 0 ? '' : '_plural';
  return "_".concat(i);
};
var getGettextValues = function getGettextValues(value, locale, targetKey, options) {
  var values = value.msgstr;
  var plurals = getPlurals(options);
  var isPlural = !!value.msgid_plural;
  if (!isPlural) return emptyOrObject(targetKey, values[0], options);
  var ext = plurals[locale.toLowerCase()] || plurals[locale.split(/_|-/)[0].toLowerCase()] || plurals.dev;
  var gettextValues = {};
  for (var i = 0; i < values.length; i += 1) {
    var pluralSuffix = getI18nextPluralExtension(ext, i);
    if (options.compatibilityJSON === 'v4') {
      var cldrRule = cldrConv[locale] || cldrConv[locale.split(/-|_/)[0]];
      if (cldrRule && cldrRule.toCldr[pluralSuffix] !== undefined && FORMS[cldrRule.toCldr[pluralSuffix]]) {
        pluralSuffix = "_".concat(FORMS[cldrRule.toCldr[pluralSuffix]]);
      }
    }
    var pkey = targetKey + pluralSuffix;
    Object.assign(gettextValues, emptyOrObject(pkey, values[i], options));
  }
  return gettextValues;
};
export default function (js) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var data = JSON.parse(JSON.stringify(js.translations));
  if (options.keyasareference) {
    var keys = [];
    Object.keys(data).forEach(function (ctx) {
      Object.keys(data[ctx]).forEach(function (key) {
        if (data[ctx][key].comments && data[ctx][key].comments.reference) {
          data[ctx][key].comments.reference.split(/\r?\n|\r/).forEach(function (id) {
            var x = data[ctx][key];
            data[ctx][id] = x;
            if (options.skipUntranslated && (x.msgstr.length === 1 && !x.msgstr[0] || isFuzzy(x))) {
              return;
            }
            if (x.msgstr[0] === '') x.msgstr[0] = x.msgid;
            for (var i = 1; i < x.msgstr.length; i += 1) {
              if (x.msgstr[i] === '') x.msgstr[i] = x.msgid_plural;
            }
            x.msgid = id;
            if (id !== key) keys.push([ctx, key]);
          });
        }
      });
    });
    keys.forEach(function (a) {
      var c = a[0];
      var k = a[1];
      delete data[c][k];
    });
  }
  var json = {};
  var separator = options.keyseparator || '##';
  var ctxSeparator = options.ctxSeparator || '_';
  var locale = options.locale || js.headers && js.headers.Language || 'en';
  Object.keys(data).forEach(function (m) {
    var context = data[m];
    Object.keys(context).forEach(function (key) {
      var targetKey = key;
      var appendTo = json;
      if (key.length === 0) {
        delete context[key];
        return;
      }
      if (options.skipUntranslated && isFuzzy(context[key])) {
        delete context[key];
        return;
      }
      if (key.indexOf(separator) > -1) {
        var _keys = key.split(separator);
        var x = 0;
        while (_keys[x] !== undefined && _keys[x] !== null) {
          if (x < _keys.length - 1) {
            appendTo[_keys[x]] = appendTo[_keys[x]] || {};
            appendTo = appendTo[_keys[x]];
          } else {
            targetKey = _keys[x];
          }
          x += 1;
        }
      }
      if (m !== '' && !options.ignoreCtx) targetKey = "".concat(targetKey).concat(ctxSeparator).concat(m);
      if (options.persistMsgIdPlural) {
        var _context$key = context[key];
        var msgid = _context$key.msgid;
        var msgid_plural = _context$key.msgid_plural;
        if (msgid_plural && msgid !== msgid_plural) targetKey = "".concat(msgid, "|#|").concat(msgid_plural);
      }
      var newValues = getGettextValues(context[key], locale, targetKey, options);
      Object.assign(appendTo, newValues);
    });
  });
  return json;
}