function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
import contentType from 'content-type';
import encoding from 'encoding';
import { HEADERS, formatCharset, compareMsgid, foldLine, generateHeader } from './shared.js';
var handleCharset = function handleCharset(table) {
  var ct = contentType.parse(table.headers['Content-Type'] || 'text/plain');
  var charset = formatCharset(table.charset || ct.parameters.charset || 'utf-8');
  if (ct.parameters.charset) {
    ct.parameters.charset = formatCharset(ct.parameters.charset);
  }
  table.charset = charset;
  table.headers['Content-Type'] = contentType.format(ct);
};
var drawComments = function drawComments(comments) {
  var lines = [];
  var types = [{
    key: 'translator',
    prefix: '# '
  }, {
    key: 'reference',
    prefix: '#: '
  }, {
    key: 'extracted',
    prefix: '#. '
  }, {
    key: 'flag',
    prefix: '#, '
  }, {
    key: 'previous',
    prefix: '#| '
  }];
  types.forEach(function (type) {
    if (!comments[type.key]) return;
    comments[type.key].split(/\r?\n|\r/).forEach(function (line) {
      lines.push("".concat(type.prefix).concat(line));
    });
  });
  return lines.join('\n');
};
var addPOString = function addPOString() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var options = arguments.length > 2 ? arguments[2] : undefined;
  key = key.toString();
  value = value.toString().replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\t/g, '\\t').replace(/\r/g, '\\r').replace(/\n/g, '\\n');
  var lines = [value];
  if (options.foldLength > 0) {
    lines = foldLine(value, options.foldLength);
  }
  if (lines.length < 2) {
    return "".concat(key, " \"").concat(lines.shift() || '', "\"");
  }
  return "".concat(key, " \"\"\n\"").concat(lines.join('"\n"'), "\"");
};
var drawBlock = function drawBlock(block) {
  var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 ? arguments[2] : undefined;
  var response = [];
  var msgctxt = override.msgctxt || block.msgctxt;
  var msgid = override.msgid || block.msgid;
  var msgidPlural = override.msgid_plural || block.msgid_plural;
  var msgstr = [].concat(override.msgstr || block.msgstr);
  var comments = override.comments || block.comments;
  if (comments && (comments = drawComments(comments))) {
    response.push(comments);
  }
  if (msgctxt) {
    response.push(addPOString('msgctxt', msgctxt, options));
  }
  response.push(addPOString('msgid', msgid || '', options));
  if (msgidPlural) {
    response.push(addPOString('msgid_plural', msgidPlural, options));
    msgstr.forEach(function (msgstr, i) {
      response.push(addPOString("msgstr[".concat(i, "]"), msgstr || '', options));
    });
    if (msgstr.length === 0) {
      response.push(addPOString('msgstr[0]', '', options));
    }
  } else {
    response.push(addPOString('msgstr', msgstr[0] || '', options));
  }
  return response.join('\n');
};
var compile = function compile(table, options) {
  var headerBlock = table.translations[''] && table.translations[''][''] || {};
  var response = [];
  Object.keys(table.translations).forEach(function (msgctxt) {
    if (_typeof(table.translations[msgctxt]) !== 'object') return;
    Object.keys(table.translations[msgctxt]).forEach(function (msgid) {
      if (_typeof(table.translations[msgctxt][msgid]) !== 'object') return;
      if (msgctxt === '' && msgid === '') return;
      response.push(table.translations[msgctxt][msgid]);
    });
  });
  if (options.sort !== false) {
    if (typeof options.sort === 'function') {
      response = response.sort(options.sort);
    } else {
      response = response.sort(compareMsgid);
    }
  }
  response = response.map(function (r) {
    return drawBlock(r, {}, options);
  });
  response.unshift(drawBlock(headerBlock, {
    msgstr: generateHeader(table.headers)
  }, options));
  if (table.charset === 'utf-8' || table.charset === 'ascii') {
    return response.join('\n\n');
  }
  return encoding.convert(response.join('\n\n'), table.charset).toString();
};
export default function () {
  var table = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  table.translations = table.translations || {};
  options.project = options.project || 'gettext-converter';
  var _table$headers = table.headers,
    headers = _table$headers === void 0 ? {} : _table$headers;
  headers = Object.keys(headers).reduce(function (result, key) {
    var lowerKey = key.toLowerCase();
    if (HEADERS.has(lowerKey)) {
      result[HEADERS.get(lowerKey)] = headers[key];
    } else {
      result[key] = headers[key];
    }
    return result;
  }, {});
  if (!headers[HEADERS.get('project-id-version')]) headers[HEADERS.get('project-id-version')] = options.project;
  table.headers = headers;
  if (!('foldLength' in options)) options.foldLength = 76;
  if (!('sort' in options)) options.sort = false;
  handleCharset(table);
  return compile(table, options);
}